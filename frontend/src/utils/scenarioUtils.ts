import { FlowNode, FlowEdge, Scenario, DialogState } from '../types/scenario';

export interface ScenarioChanges {
  added: DialogState[];
  modified: DialogState[];
  removed: DialogState[];
}

/**
 * FlowNode 배열을 Scenario JSON 형식으로 변환
 */
export const convertNodesToScenario = (
  nodes: FlowNode[],
  edges: FlowEdge[],
  originalScenario?: Scenario | null,
  scenarioName?: string,
  scenarios?: Record<string, Scenario> // 시나리오 ID→객체 맵 추가
): Scenario => {
  // 기본 시나리오 구조 생성
  const baseScenario: Scenario = originalScenario ? { ...originalScenario } : {
    plan: [
      {
        name: scenarioName || "MainPlan",
        dialogState: []
      }
    ],
    botConfig: {
      botType: "CONVERSATIONAL"
    },
    intentMapping: [],
    multiIntentMapping: [],
    handlerGroups: [],
    webhooks: [],
    dialogResult: "END_SESSION"
  };

  // 모든 핸들러의 transitionTarget에서 scenario가 비어 있으면 현재 시나리오 이름으로 채움
  function fillScenarioIfEmpty(handler: any) {
    if (handler && handler.transitionTarget) {
      if (
        (!handler.transitionTarget.scenario || handler.transitionTarget.scenario === "") &&
        handler.transitionTarget.dialogState
      ) {
        // 현재 시나리오 이름 추정 (노드의 시나리오 이름이 필요할 경우 추가 인자로 받아야 함)
        handler.transitionTarget.scenario = scenarioName || (originalScenario?.plan?.[0]?.name) || "MainPlan";
      }
    }
    return handler;
  }

  // 모든 핸들러의 transitionTarget에서 scenario가 id(예: 'scenario-...')이면 name으로 변환
  function normalizeScenarioName(handler: any) {
    if (handler && handler.transitionTarget && typeof handler.transitionTarget.scenario === 'string') {
      const scenarioVal = handler.transitionTarget.scenario;
      if (scenarioVal.startsWith('scenario-') && scenarios && (scenarios as any)[scenarioVal]) {
        // 시나리오 이름 추출 (타입 안전하게)
        const scenarioName = (scenarios as any)[scenarioVal]?.scenario?.plan?.[0]?.name;
        if (scenarioName) handler.transitionTarget.scenario = scenarioName;
      }
    }
    return handler;
  }

  // fillScenarioIfEmpty와 normalizeScenarioName을 모두 적용
  function processHandler(handler: any) {
    return normalizeScenarioName(fillScenarioIfEmpty(handler));
  }

  // 일반 상태 노드만 변환 (자동 생성된 종료 노드 제외)
  const dialogStates: DialogState[] = nodes.filter(node => {
    // 자동 생성된 종료 노드인지 확인 (더 정확한 필터링)
    const isAutoGeneratedEndNode = (
      (node.type === 'custom' && node.id.startsWith('end-')) ||
      (node.data.dialogState.name === '__END_SCENARIO__' || 
       node.data.dialogState.name === '__END_SESSION__' || 
       node.data.dialogState.name === '__END_PROCESS__')
    );
    
    return node.type !== 'scenarioTransition' && !isAutoGeneratedEndNode;
  }).map(node => {
    // 모든 핸들러에서 scenarioTransition 노드로 전이하는 경우, 실제 타겟 시나리오/상태로 치환
    const ds = { ...node.data.dialogState };
    // conditionHandlers
    if (ds.conditionHandlers) {
      ds.conditionHandlers = ds.conditionHandlers.map((handler: any) => {
        let t = handler.transitionTarget;
        // transitionTarget.scenario가 id면 name으로 변환
        if (t && typeof t.scenario === 'string' && t.scenario.startsWith('scenario-') && scenarios && scenarios[t.scenario]) {
          t.scenario = scenarios[t.scenario].plan[0].name;
        }
        if (t && t.dialogState) {
          const st = scenarios?.[t.dialogState];
          if (st) {
            const scenarioName = st?.plan?.[0]?.name;
            const stateObj = st?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
        }
        t = fillScenarioIfEmpty(t);
        return { ...handler, transitionTarget: t };
      });
    }
    // intentHandlers
    if (ds.intentHandlers) {
      ds.intentHandlers = ds.intentHandlers.map((handler: any) => {
        let t = handler.transitionTarget;
        if (t && typeof t.scenario === 'string' && t.scenario.startsWith('scenario-') && scenarios && scenarios[t.scenario]) {
          t.scenario = scenarios[t.scenario].plan[0].name;
        }
        if (t && t.dialogState) {
          const st = scenarios?.[t.dialogState];
          if (st) {
            const scenarioName = st?.plan?.[0]?.name;
            const stateObj = st?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
        }
        t = fillScenarioIfEmpty(t);
        return { ...handler, transitionTarget: t };
      });
    }
    // eventHandlers
    if (ds.eventHandlers) {
      ds.eventHandlers = ds.eventHandlers.map((handler: any) => {
        let t = handler.transitionTarget;
        if (t && typeof t.scenario === 'string' && t.scenario.startsWith('scenario-') && scenarios && scenarios[t.scenario]) {
          t.scenario = scenarios[t.scenario].plan[0].name;
        }
        if (t && t.dialogState) {
          const st = scenarios?.[t.dialogState];
          if (st) {
            const scenarioName = st?.plan?.[0]?.name;
            const stateObj = st?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
        }
        t = fillScenarioIfEmpty(t);
        return { ...handler, transitionTarget: t };
      });
    }
    // apicallHandlers
    if (ds.apicallHandlers) {
      ds.apicallHandlers = ds.apicallHandlers.map((handler: any) => {
        let t = handler.transitionTarget;
        if (t && typeof t.scenario === 'string' && t.scenario.startsWith('scenario-') && scenarios && scenarios[t.scenario]) {
          t.scenario = scenarios[t.scenario].plan[0].name;
        }
        if (t && t.dialogState) {
          const st = scenarios?.[t.dialogState];
          if (st) {
            const scenarioName = st?.plan?.[0]?.name;
            const stateObj = st?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
        }
        t = fillScenarioIfEmpty(t);
        return { ...handler, transitionTarget: t };
      });
    }
    return ds;
  });

  // 각 노드의 핸들러에 대해 processHandler를 적용
  nodes.forEach(node => {
    if (node.data && node.data.dialogState) {
      if (Array.isArray(node.data.dialogState.conditionHandlers)) {
        node.data.dialogState.conditionHandlers = node.data.dialogState.conditionHandlers.map(processHandler);
      }
      if (Array.isArray(node.data.dialogState.intentHandlers)) {
        node.data.dialogState.intentHandlers = node.data.dialogState.intentHandlers.map(processHandler);
      }
      if (Array.isArray(node.data.dialogState.eventHandlers)) {
        node.data.dialogState.eventHandlers = node.data.dialogState.eventHandlers.map(processHandler);
      }
      if (Array.isArray(node.data.dialogState.apicallHandlers)) {
        node.data.dialogState.apicallHandlers = node.data.dialogState.apicallHandlers.map(processHandler);
      }
    }
  });

  // 핸들러 내부에서 scenarioTransitionNode 전이 처리 시
  // t.dialogState가 state id라면, 해당 시나리오에서 state name을 찾아 string으로 할당
  nodes.forEach(node => {
    if (node.data && node.data.dialogState) {
      if (Array.isArray(node.data.dialogState.conditionHandlers)) {
        node.data.dialogState.conditionHandlers = node.data.dialogState.conditionHandlers.map((handler: any) => {
          let t = handler.transitionTarget;
          if (t && t.dialogState && scenarios && (scenarios as any)[t.scenario]) {
            const st = (scenarios as any)[t.scenario];
            const scenarioName = st?.scenario?.plan?.[0]?.name;
            const stateObj = st?.scenario?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
          t = fillScenarioIfEmpty(t);
          return { ...handler, transitionTarget: t };
        });
      }
      if (Array.isArray(node.data.dialogState.intentHandlers)) {
        node.data.dialogState.intentHandlers = node.data.dialogState.intentHandlers.map((handler: any) => {
          let t = handler.transitionTarget;
          if (t && t.dialogState && scenarios && (scenarios as any)[t.scenario]) {
            const st = (scenarios as any)[t.scenario];
            const scenarioName = st?.scenario?.plan?.[0]?.name;
            const stateObj = st?.scenario?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
          t = fillScenarioIfEmpty(t);
          return { ...handler, transitionTarget: t };
        });
      }
      if (Array.isArray(node.data.dialogState.eventHandlers)) {
        node.data.dialogState.eventHandlers = node.data.dialogState.eventHandlers.map((handler: any) => {
          let t = handler.transitionTarget;
          if (t && t.dialogState && scenarios && (scenarios as any)[t.scenario]) {
            const st = (scenarios as any)[t.scenario];
            const scenarioName = st?.scenario?.plan?.[0]?.name;
            const stateObj = st?.scenario?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
          t = fillScenarioIfEmpty(t);
          return { ...handler, transitionTarget: t };
        });
      }
      if (Array.isArray(node.data.dialogState.apicallHandlers)) {
        node.data.dialogState.apicallHandlers = node.data.dialogState.apicallHandlers.map((handler: any) => {
          let t = handler.transitionTarget;
          if (t && t.dialogState && scenarios && (scenarios as any)[t.scenario]) {
            const st = (scenarios as any)[t.scenario];
            const scenarioName = st?.scenario?.plan?.[0]?.name;
            const stateObj = st?.scenario?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
          t = fillScenarioIfEmpty(t);
          return { ...handler, transitionTarget: t };
        });
      }
    }
  });

  // --- 시나리오 전이 판단 로직 ---
  // transitionTarget의 scenarioName으로 시나리오 전이를 판단
  // scenarioName이 현재 시나리오와 다른 경우 시나리오 전이로 간주
  
  // 모든 노드의 id를 key로 매핑
  const nodeMap = Object.fromEntries(nodes.map(n => [n.id, n]));

  // edges에서 source/target 추출
  const allEdges: { source: string; target: string }[] = edges.map(e => ({ source: e.source, target: e.target }));

  // 시나리오 전이 노드들을 찾아서 dialogState의 handler로 변환
  const scenarioTransitionNodes = nodes.filter(node => node.type === 'scenarioTransition');
  
  scenarioTransitionNodes.forEach(stNode => {
    // source 노드 찾기 (edge의 target이 stNode.id인 edge의 source)
    const sourceEdge = allEdges.find(e => e.target === stNode.id);
    if (!sourceEdge) return;
    const sourceNode = nodeMap[sourceEdge.source];
    if (!sourceNode || !sourceNode.data || !sourceNode.data.dialogState) return;
    
    // 원본 핸들러 타입을 유지하기 위해 edge의 label을 분석하여 핸들러 타입 결정
    const edgeLabel = edges.find(e => e.source === sourceNode.id && e.target === stNode.id)?.label || '';
    let handlerType: 'conditionHandler' | 'intentHandler' | 'eventHandler' = 'conditionHandler';
    
    if (edgeLabel.includes('인텐트:')) {
      handlerType = 'intentHandler';
    } else if (edgeLabel.includes('이벤트:')) {
      handlerType = 'eventHandler';
    } else if (edgeLabel.includes('조건:')) {
      handlerType = 'conditionHandler';
    }
    
    // 중복 체크: 이미 동일한 transitionTarget을 가진 핸들러가 있는지 확인
    const existingHandler = (sourceNode.data.dialogState as any)[handlerType + 's']?.find((handler: any) => 
      handler.transitionTarget?.scenario === stNode.data.targetScenario &&
      handler.transitionTarget?.dialogState === stNode.data.targetState
    );
    
    // 중복된 핸들러가 있으면 추가하지 않음
    if (existingHandler) {
      return;
    }
    
    // 핸들러 타입에 따라 적절한 핸들러 생성
    let handler: any;
    
    if (handlerType === 'intentHandler') {
      handler = {
        intent: edgeLabel.replace('인텐트: ', '') || 'default_intent',
        action: {},
        transitionTarget: {
          scenario: stNode.data.targetScenario || '',
          dialogState: stNode.data.targetState || ''
        }
      };
    } else if (handlerType === 'eventHandler') {
      handler = {
        event: {
          type: edgeLabel.replace('이벤트: ', '') || 'default_event',
          count: "1"
        },
        action: {},
        transitionTarget: {
          scenario: stNode.data.targetScenario || '',
          dialogState: stNode.data.targetState || ''
        }
      };
    } else {
      // conditionHandler (기본값)
      handler = {
        conditionStatement: edgeLabel.replace('조건: ', '') || 'True',
        action: {},
        transitionTarget: {
          scenario: stNode.data.targetScenario || '',
          dialogState: stNode.data.targetState || ''
        }
      };
    }
    
    // 해당 타입의 핸들러 배열에 추가
    const handlerArrayKey = handlerType + 's';
    if (!(sourceNode.data.dialogState as any)[handlerArrayKey]) {
      (sourceNode.data.dialogState as any)[handlerArrayKey] = [];
    }
    (sourceNode.data.dialogState as any)[handlerArrayKey].push(handler);
  });

  // 최신 시나리오 이름을 적용
  const updatedScenario: Scenario = {
    ...baseScenario,
    plan: [
      {
        ...baseScenario.plan[0],
        name: scenarioName || baseScenario.plan[0].name,
        dialogState: dialogStates,
      }
    ]
  };

  return updatedScenario;
};

/**
 * 두 DialogState가 동일한지 비교 (깊은 비교)
 */
const areDialogStatesEqual = (state1: DialogState, state2: DialogState): boolean => {
  try {
    return JSON.stringify(state1) === JSON.stringify(state2);
  } catch {
    return false;
  }
};

/**
 * 원본 시나리오와 현재 노드들을 비교하여 변경사항 분석
 */
export const compareScenarios = (
  currentNodes: FlowNode[],
  originalScenario: Scenario | null
): ScenarioChanges => {
  const changes: ScenarioChanges = {
    added: [],
    modified: [],
    removed: []
  };

  if (!originalScenario || !originalScenario.plan[0]?.dialogState) {
    // 원본이 없으면 자동 생성된 종료 노드를 제외한 현재 노드들을 추가된 것으로 간주
    const filteredNodes = currentNodes.filter(node => {
      const isAutoGeneratedEndNode = (
        (node.type === 'custom' && node.id.startsWith('end-')) ||
        (node.data.dialogState.name === '__END_SCENARIO__' || 
         node.data.dialogState.name === '__END_SESSION__' || 
         node.data.dialogState.name === '__END_PROCESS__')
      );
      return !isAutoGeneratedEndNode;
    });
    changes.added = filteredNodes.map(node => node.data.dialogState);
    return changes;
  }

  const originalStates = originalScenario.plan[0].dialogState;
  
  // 자동 생성된 종료 노드를 완전히 제외한 현재 상태들만 추출
  const currentStates = currentNodes
    .filter(node => {
      // 자동 생성된 종료 노드인지 확인 (더 정확한 필터링)
      const isAutoGeneratedEndNode = (
        (node.type === 'custom' && node.id.startsWith('end-')) ||
        (node.data.dialogState.name === '__END_SCENARIO__' || 
         node.data.dialogState.name === '__END_SESSION__' || 
         node.data.dialogState.name === '__END_PROCESS__')
      );
      
      // 시나리오/플랜 전이 노드도 제외하고, 자동 생성된 종료 노드도 제외
      return node.type !== 'scenarioTransition' && node.type !== 'planTransition' && !isAutoGeneratedEndNode;
    })
    .map(node => node.data.dialogState);

  // 원본에서 이름으로 매핑 생성
  const originalStateMap = new Map<string, DialogState>();
  originalStates.forEach(state => {
    originalStateMap.set(state.name, state);
  });

  // 현재 상태에서 이름으로 매핑 생성
  const currentStateMap = new Map<string, DialogState>();
  currentStates.forEach(state => {
    currentStateMap.set(state.name, state);
  });

  // 추가된 상태와 수정된 상태 찾기
  currentStates.forEach(currentState => {
    const originalState = originalStateMap.get(currentState.name);
    
    if (!originalState) {
      // 새로 추가된 상태
      changes.added.push(currentState);
    } else if (!areDialogStatesEqual(originalState, currentState)) {
      // 수정된 상태
      changes.modified.push(currentState);
    }
  });

  // 삭제된 상태 찾기
  originalStates.forEach(originalState => {
    if (!currentStateMap.has(originalState.name)) {
      changes.removed.push(originalState);
    }
  });

  // 시나리오 전이 노드 비교 (자동 생성된 종료 노드 완전 제외)
  // 시나리오 전이 노드들은 transitionTarget의 scenarioName으로 판단되므로 별도 비교 불필요
  
  return changes;
};

/**
 * 시나리오를 JSON 파일로 다운로드
 */
export const downloadScenarioAsJSON = (scenario: Scenario, filename: string) => {
  // 보안을 위해 apicall.url 필드 제거
  const scenarioForDownload = JSON.parse(JSON.stringify(scenario));
  removeApiCallUrlsFromScenario(scenarioForDownload);
  
  const dataStr = JSON.stringify(scenarioForDownload, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  const url = URL.createObjectURL(dataBlob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = filename.endsWith('.json') ? filename : `${filename}.json`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

/**
 * 시나리오 유효성 검증
 */
export const validateScenario = (scenario: any): boolean => {
  if (!scenario || typeof scenario !== 'object') return false;
  if (!scenario.plan || !Array.isArray(scenario.plan)) return false;
  if (scenario.plan.length === 0) return false;
  
  const firstPlan = scenario.plan[0];
  if (!firstPlan.dialogState || !Array.isArray(firstPlan.dialogState)) return false;
  
  return true;
};

/**
 * 변경사항이 있는지 확인
 */
export const hasScenarioChanges = (changes: ScenarioChanges): boolean => {
  return changes.added.length > 0 || 
         changes.modified.length > 0 || 
         changes.removed.length > 0;
};

/**
 * 변경사항 요약 텍스트 생성
 */
export const getChangesSummary = (changes: ScenarioChanges): string => {
  const parts: string[] = [];
  
  if (changes.added.length > 0) {
    parts.push(`${changes.added.length}개 추가`);
  }
  
  if (changes.modified.length > 0) {
    parts.push(`${changes.modified.length}개 수정`);
  }
  
  if (changes.removed.length > 0) {
    parts.push(`${changes.removed.length}개 삭제`);
  }
  
  return parts.length > 0 ? parts.join(', ') : '변경사항 없음';
}; 

/**
 * 모든 apicallHandlers의 apicall.url 필드를 삭제 (보안/내보내기용)
 */
export function removeApiCallUrlsFromScenario(scenarioOrArray: any) {
  // 여러 시나리오 배열 지원
  const scenarios = Array.isArray(scenarioOrArray) ? scenarioOrArray : [scenarioOrArray];
  scenarios.forEach((scenario) => {
    if (!scenario?.plan) return;
    scenario.plan.forEach((plan: any) => {
      if (!plan?.dialogState) return;
      plan.dialogState.forEach((state: any) => {
        if (Array.isArray(state.apicallHandlers)) {
          state.apicallHandlers.forEach((handler: any) => {
            if (handler.apicall && handler.apicall.url) {
              // eslint-disable-next-line no-console
              console.info(`[REMOVE_URL] state: ${state.name}, handler: ${handler.name} - url 삭제됨 (removed)`);
              delete handler.apicall.url;
            } else {
              // eslint-disable-next-line no-console
              console.info(`[REMOVE_URL] state: ${state.name}, handler: ${handler.name} - url 없음 (no url field)`);
            }
          });
        }
      });
    });
  });
} 

/**
 * 시나리오 전이 검증
 * targetScenario가 실제로 존재하는지 확인하고, 시나리오와 플랜을 구분
 */
export const validateScenarioTransition = (
  targetScenarioName: string,
  scenarios: Record<string, any>,
  currentScenarioName: string
): { isValid: boolean; errorMessage?: string; isScenarioTransition: boolean } => {
  // 현재 시나리오와 같은 이름이면 플랜 전이
  if (targetScenarioName === currentScenarioName) {
    return { isValid: true, isScenarioTransition: false };
  }
  
  // 다른 시나리오 이름이면 시나리오 전이
  // targetScenarioName이 실제로 존재하는지 확인
  const targetScenarioExists = Object.values(scenarios).some(scenario => 
    scenario.plan[0]?.name === targetScenarioName
  );
  
  if (!targetScenarioExists) {
    return { 
      isValid: false, 
      errorMessage: `참조하는 시나리오 '${targetScenarioName}'가 존재하지 않습니다.`,
      isScenarioTransition: true
    };
  }
  
  return { isValid: true, isScenarioTransition: true };
};

/**
 * 시나리오 구조에서 plan과 scenario를 구분
 * 시나리오 파일은 새로운 시나리오 ID와 이름을 갖고 있고, 시나리오 내에 plan 필드가 따로 존재
 */
export const isScenarioStructure = (data: any): boolean => {
  return data && 
         typeof data === 'object' && 
         data.id && 
         data.name && 
         data.scenario && 
         data.scenario.plan;
};

/**
 * 플랜 구조인지 확인
 * 플랜은 name과 dialogState만 가짐
 */
export const isPlanStructure = (data: any): boolean => {
  return data && 
         typeof data === 'object' && 
         data.name && 
         data.dialogState && 
         !data.id && 
         !data.scenario;
}; 

/**
 * 시나리오 저장 시 불필요한 필드 제거
 * scenarioTransitionNodes는 더 이상 사용하지 않음
 */
export const cleanScenarioForSave = (scenario: Scenario): Scenario => {
  const cleanedScenario = JSON.parse(JSON.stringify(scenario));
  
  // plan에서 scenarioTransitionNodes 제거
  if (cleanedScenario.plan && Array.isArray(cleanedScenario.plan)) {
    cleanedScenario.plan.forEach((plan: any) => {
      if (plan.scenarioTransitionNodes) {
        delete plan.scenarioTransitionNodes;
      }
    });
  }
  
  return cleanedScenario;
}; 