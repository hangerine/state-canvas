import { FlowNode, FlowEdge, Scenario, DialogState } from '../types/scenario';

export interface ScenarioChanges {
  added: DialogState[];
  modified: DialogState[];
  removed: DialogState[];
}

/**
 * FlowNode 배열을 Scenario JSON 형식으로 변환
 */
export const convertNodesToScenario = (
  nodes: FlowNode[],
  edges: FlowEdge[],
  originalScenario?: Scenario | null,
  scenarioName?: string,
  scenarios?: Record<string, Scenario> // 시나리오 ID→객체 맵 추가
): Scenario => {
  // 기본 시나리오 구조 생성
  const baseScenario: Scenario = originalScenario ? { ...originalScenario } : {
    plan: [
      {
        name: scenarioName || "MainPlan",
        dialogState: []
      }
    ],
    botConfig: {
      botType: "CONVERSATIONAL"
    },
    intentMapping: [],
    multiIntentMapping: [],
    handlerGroups: [],
    webhooks: [],
    dialogResult: "END_SESSION"
  };

  // 모든 핸들러의 transitionTarget에서 scenario가 비어 있으면 현재 시나리오 이름으로 채움
  function fillScenarioIfEmpty(handler: any) {
    if (handler && handler.transitionTarget) {
      if (
        (!handler.transitionTarget.scenario || handler.transitionTarget.scenario === "") &&
        handler.transitionTarget.dialogState
      ) {
        // 현재 시나리오 이름 추정 (노드의 시나리오 이름이 필요할 경우 추가 인자로 받아야 함)
        handler.transitionTarget.scenario = scenarioName || (originalScenario?.plan?.[0]?.name) || "MainPlan";
      }
    }
    return handler;
  }

  // 모든 핸들러의 transitionTarget에서 scenario가 id(예: 'scenario-...')이면 name으로 변환
  function normalizeScenarioName(handler: any) {
    if (handler && handler.transitionTarget && typeof handler.transitionTarget.scenario === 'string') {
      const scenarioVal = handler.transitionTarget.scenario;
      if (scenarioVal.startsWith('scenario-') && scenarios && (scenarios as any)[scenarioVal]) {
        // 시나리오 이름 추출 (타입 안전하게)
        const scenarioName = (scenarios as any)[scenarioVal]?.scenario?.plan?.[0]?.name;
        if (scenarioName) handler.transitionTarget.scenario = scenarioName;
      }
    }
    return handler;
  }

  // fillScenarioIfEmpty와 normalizeScenarioName을 모두 적용
  function processHandler(handler: any) {
    return normalizeScenarioName(fillScenarioIfEmpty(handler));
  }

  // 일반 상태 노드만 변환 (자동 생성된 종료 노드 제외)
  const dialogStates: DialogState[] = nodes.filter(node => {
    // 자동 생성된 종료 노드인지 확인 (더 정확한 필터링)
    const isAutoGeneratedEndNode = (
      (node.type === 'custom' && node.id.startsWith('end-')) ||
      (node.data.dialogState.name === '__END_SCENARIO__' || 
       node.data.dialogState.name === '__END_SESSION__' || 
       node.data.dialogState.name === '__END_PROCESS__')
    );
    
    return node.type !== 'scenarioTransition' && !isAutoGeneratedEndNode;
  }).map(node => {
    // 모든 핸들러에서 scenarioTransition 노드로 전이하는 경우, 실제 타겟 시나리오/상태로 치환
    const ds = { ...node.data.dialogState };
    // conditionHandlers
    if (ds.conditionHandlers) {
      ds.conditionHandlers = ds.conditionHandlers.map((handler: any) => {
        let t = handler.transitionTarget;
        // transitionTarget.scenario가 id면 name으로 변환
        if (t && typeof t.scenario === 'string' && t.scenario.startsWith('scenario-') && scenarios && scenarios[t.scenario]) {
          t.scenario = scenarios[t.scenario].plan[0].name;
        }
        if (t && t.dialogState) {
          const st = scenarios?.[t.dialogState];
          if (st) {
            const scenarioName = st?.plan?.[0]?.name;
            const stateObj = st?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
        }
        t = fillScenarioIfEmpty(t);
        return { ...handler, transitionTarget: t };
      });
    }
    // intentHandlers
    if (ds.intentHandlers) {
      ds.intentHandlers = ds.intentHandlers.map((handler: any) => {
        let t = handler.transitionTarget;
        if (t && typeof t.scenario === 'string' && t.scenario.startsWith('scenario-') && scenarios && scenarios[t.scenario]) {
          t.scenario = scenarios[t.scenario].plan[0].name;
        }
        if (t && t.dialogState) {
          const st = scenarios?.[t.dialogState];
          if (st) {
            const scenarioName = st?.plan?.[0]?.name;
            const stateObj = st?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
        }
        t = fillScenarioIfEmpty(t);
        return { ...handler, transitionTarget: t };
      });
    }
    // eventHandlers
    if (ds.eventHandlers) {
      ds.eventHandlers = ds.eventHandlers.map((handler: any) => {
        let t = handler.transitionTarget;
        if (t && typeof t.scenario === 'string' && t.scenario.startsWith('scenario-') && scenarios && scenarios[t.scenario]) {
          t.scenario = scenarios[t.scenario].plan[0].name;
        }
        if (t && t.dialogState) {
          const st = scenarios?.[t.dialogState];
          if (st) {
            const scenarioName = st?.plan?.[0]?.name;
            const stateObj = st?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
        }
        t = fillScenarioIfEmpty(t);
        return { ...handler, transitionTarget: t };
      });
    }
    // apicallHandlers
    if (ds.apicallHandlers) {
      ds.apicallHandlers = ds.apicallHandlers.map((handler: any) => {
        let t = handler.transitionTarget;
        if (t && typeof t.scenario === 'string' && t.scenario.startsWith('scenario-') && scenarios && scenarios[t.scenario]) {
          t.scenario = scenarios[t.scenario].plan[0].name;
        }
        if (t && t.dialogState) {
          const st = scenarios?.[t.dialogState];
          if (st) {
            const scenarioName = st?.plan?.[0]?.name;
            const stateObj = st?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
        }
        t = fillScenarioIfEmpty(t);
        return { ...handler, transitionTarget: t };
      });
    }
    return ds;
  });

  // 각 노드의 핸들러에 대해 processHandler를 적용
  nodes.forEach(node => {
    if (node.data && node.data.dialogState) {
      if (Array.isArray(node.data.dialogState.conditionHandlers)) {
        node.data.dialogState.conditionHandlers = node.data.dialogState.conditionHandlers.map(processHandler);
      }
      if (Array.isArray(node.data.dialogState.intentHandlers)) {
        node.data.dialogState.intentHandlers = node.data.dialogState.intentHandlers.map(processHandler);
      }
      if (Array.isArray(node.data.dialogState.eventHandlers)) {
        node.data.dialogState.eventHandlers = node.data.dialogState.eventHandlers.map(processHandler);
      }
      if (Array.isArray(node.data.dialogState.apicallHandlers)) {
        node.data.dialogState.apicallHandlers = node.data.dialogState.apicallHandlers.map(processHandler);
      }
    }
  });

  // 핸들러 내부에서 scenarioTransitionNode 전이 처리 시
  // t.dialogState가 state id라면, 해당 시나리오에서 state name을 찾아 string으로 할당
  nodes.forEach(node => {
    if (node.data && node.data.dialogState) {
      if (Array.isArray(node.data.dialogState.conditionHandlers)) {
        node.data.dialogState.conditionHandlers = node.data.dialogState.conditionHandlers.map((handler: any) => {
          let t = handler.transitionTarget;
          if (t && t.dialogState && scenarios && (scenarios as any)[t.scenario]) {
            const st = (scenarios as any)[t.scenario];
            const scenarioName = st?.scenario?.plan?.[0]?.name;
            const stateObj = st?.scenario?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
          t = fillScenarioIfEmpty(t);
          return { ...handler, transitionTarget: t };
        });
      }
      if (Array.isArray(node.data.dialogState.intentHandlers)) {
        node.data.dialogState.intentHandlers = node.data.dialogState.intentHandlers.map((handler: any) => {
          let t = handler.transitionTarget;
          if (t && t.dialogState && scenarios && (scenarios as any)[t.scenario]) {
            const st = (scenarios as any)[t.scenario];
            const scenarioName = st?.scenario?.plan?.[0]?.name;
            const stateObj = st?.scenario?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
          t = fillScenarioIfEmpty(t);
          return { ...handler, transitionTarget: t };
        });
      }
      if (Array.isArray(node.data.dialogState.eventHandlers)) {
        node.data.dialogState.eventHandlers = node.data.dialogState.eventHandlers.map((handler: any) => {
          let t = handler.transitionTarget;
          if (t && t.dialogState && scenarios && (scenarios as any)[t.scenario]) {
            const st = (scenarios as any)[t.scenario];
            const scenarioName = st?.scenario?.plan?.[0]?.name;
            const stateObj = st?.scenario?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
          t = fillScenarioIfEmpty(t);
          return { ...handler, transitionTarget: t };
        });
      }
      if (Array.isArray(node.data.dialogState.apicallHandlers)) {
        node.data.dialogState.apicallHandlers = node.data.dialogState.apicallHandlers.map((handler: any) => {
          let t = handler.transitionTarget;
          if (t && t.dialogState && scenarios && (scenarios as any)[t.scenario]) {
            const st = (scenarios as any)[t.scenario];
            const scenarioName = st?.scenario?.plan?.[0]?.name;
            const stateObj = st?.scenario?.plan?.[0]?.dialogState?.find((ds: any) => ds.name === t?.dialogState);
            if (stateObj && scenarioName) {
              t = { scenario: scenarioName, dialogState: stateObj.name };
            }
          }
          t = fillScenarioIfEmpty(t);
          return { ...handler, transitionTarget: t };
        });
      }
    }
  });

  // --- scenarioTransitionNodes를 dialogState의 handler로 변환 ---
  // 1. scenarioTransitionNodes 추출 (자동 생성된 종료 노드 제외)
  const scenarioTransitionNodesArr = nodes.filter(node => {
    // 자동 생성된 종료 노드인지 확인 (더 정확한 필터링)
    const isAutoGeneratedEndNode = (
      (node.type === 'custom' && node.id.startsWith('end-')) ||
      (node.data.dialogState.name === '__END_SCENARIO__' || 
       node.data.dialogState.name === '__END_SESSION__' || 
       node.data.dialogState.name === '__END_PROCESS__')
    );
    
    return node.type === 'scenarioTransition' && !isAutoGeneratedEndNode;
  });

  // 2. 모든 노드의 id를 key로 매핑
  const nodeMap = Object.fromEntries(nodes.map(n => [n.id, n]));

  // 3. edges에서 source/target 추출
  const allEdges: { source: string; target: string }[] = edges.map(e => ({ source: e.source, target: e.target }));

  // scenarioTransitionNodes를 dialogState의 handler로 변환
  scenarioTransitionNodesArr.forEach(stNode => {
    // source 노드 찾기 (edge의 target이 stNode.id인 edge의 source)
    const sourceEdge = allEdges.find(e => e.target === stNode.id);
    if (!sourceEdge) return;
    const sourceNode = nodeMap[sourceEdge.source];
    if (!sourceNode || !sourceNode.data || !sourceNode.data.dialogState) return;
    
    // 원본 핸들러 타입을 유지하기 위해 edge의 label을 분석하여 핸들러 타입 결정
    const edgeLabel = edges.find(e => e.source === sourceNode.id && e.target === stNode.id)?.label || '';
    let handlerType: 'conditionHandler' | 'intentHandler' | 'eventHandler' = 'conditionHandler';
    
    if (edgeLabel.includes('인텐트:')) {
      handlerType = 'intentHandler';
    } else if (edgeLabel.includes('이벤트:')) {
      handlerType = 'eventHandler';
    } else if (edgeLabel.includes('조건:')) {
      handlerType = 'conditionHandler';
    }
    
    // 중복 체크: 이미 동일한 transitionTarget을 가진 핸들러가 있는지 확인
    const existingHandler = (sourceNode.data.dialogState as any)[handlerType + 's']?.find((handler: any) => 
      handler.transitionTarget?.scenario === stNode.data.targetScenario &&
      handler.transitionTarget?.dialogState === stNode.data.targetState
    );
    
    // 중복된 핸들러가 있으면 추가하지 않음
    if (existingHandler) {
      return;
    }
    
    // 핸들러 타입에 따라 적절한 핸들러 생성
    let handler: any;
    
    if (handlerType === 'intentHandler') {
      handler = {
        intent: edgeLabel.replace('인텐트: ', '') || 'default_intent',
        action: {},
        transitionTarget: {
          scenario: stNode.data.targetScenario || '',
          dialogState: stNode.data.targetState || ''
        }
      };
    } else if (handlerType === 'eventHandler') {
      handler = {
        event: {
          type: edgeLabel.replace('이벤트: ', '') || 'default_event',
          count: "1"
        },
        action: {},
        transitionTarget: {
          scenario: stNode.data.targetScenario || '',
          dialogState: stNode.data.targetState || ''
        }
      };
    } else {
      // conditionHandler (기본값)
      handler = {
        conditionStatement: edgeLabel.replace('조건: ', '') || 'True',
        action: {},
        transitionTarget: {
          scenario: stNode.data.targetScenario || '',
          dialogState: stNode.data.targetState || ''
        }
      };
    }
    
    // 해당 타입의 핸들러 배열에 추가
    const handlerArrayKey = handlerType + 's';
    if (!(sourceNode.data.dialogState as any)[handlerArrayKey]) {
      (sourceNode.data.dialogState as any)[handlerArrayKey] = [];
    }
    (sourceNode.data.dialogState as any)[handlerArrayKey].push(handler);
  });

  // scenarioTransitionNodes의 targetScenario도 name으로 변환
  let scenarioTransitionNodes = baseScenario.plan[0].scenarioTransitionNodes;
  if (scenarioTransitionNodes) {
    scenarioTransitionNodes = scenarioTransitionNodes.map(node => {
      const targetScenarioId = node.data.targetScenario;
      if (
        targetScenarioId &&
        typeof targetScenarioId === 'string' &&
        targetScenarioId.startsWith('scenario-') &&
        scenarios &&
        scenarios[targetScenarioId]
      ) {
        node = {
          ...node,
          data: {
            ...node.data,
            targetScenario: scenarios[targetScenarioId].plan[0].name
          }
        };
      }
      return node;
    });
  }

  // 최신 시나리오 이름을 적용
  const updatedScenario: Scenario = {
    ...baseScenario,
    plan: [
      {
        ...baseScenario.plan[0],
        name: scenarioName || baseScenario.plan[0].name,
        dialogState: dialogStates,
        ...(scenarioTransitionNodes && { scenarioTransitionNodes })
      }
    ]
  };

  return updatedScenario;
};

/**
 * 두 DialogState가 동일한지 비교 (깊은 비교)
 */
const areDialogStatesEqual = (state1: DialogState, state2: DialogState): boolean => {
  try {
    return JSON.stringify(state1) === JSON.stringify(state2);
  } catch {
    return false;
  }
};

/**
 * 원본 시나리오와 현재 노드들을 비교하여 변경사항 분석
 */
export const compareScenarios = (
  currentNodes: FlowNode[],
  originalScenario: Scenario | null
): ScenarioChanges => {
  const changes: ScenarioChanges = {
    added: [],
    modified: [],
    removed: []
  };

  if (!originalScenario || !originalScenario.plan[0]?.dialogState) {
    // 원본이 없으면 자동 생성된 종료 노드를 제외한 현재 노드들을 추가된 것으로 간주
    const filteredNodes = currentNodes.filter(node => {
      const isAutoGeneratedEndNode = (
        (node.type === 'custom' && node.id.startsWith('end-')) ||
        (node.data.dialogState.name === '__END_SCENARIO__' || 
         node.data.dialogState.name === '__END_SESSION__' || 
         node.data.dialogState.name === '__END_PROCESS__')
      );
      return !isAutoGeneratedEndNode;
    });
    changes.added = filteredNodes.map(node => node.data.dialogState);
    return changes;
  }

  const originalStates = originalScenario.plan[0].dialogState;
  
  // 자동 생성된 종료 노드를 완전히 제외한 현재 상태들만 추출
  const currentStates = currentNodes
    .filter(node => {
      // 자동 생성된 종료 노드인지 확인 (더 정확한 필터링)
      const isAutoGeneratedEndNode = (
        (node.type === 'custom' && node.id.startsWith('end-')) ||
        (node.data.dialogState.name === '__END_SCENARIO__' || 
         node.data.dialogState.name === '__END_SESSION__' || 
         node.data.dialogState.name === '__END_PROCESS__')
      );
      
      // 시나리오/플랜 전이 노드도 제외하고, 자동 생성된 종료 노드도 제외
      return node.type !== 'scenarioTransition' && node.type !== 'planTransition' && !isAutoGeneratedEndNode;
    })
    .map(node => node.data.dialogState);

  // 원본에서 이름으로 매핑 생성
  const originalStateMap = new Map<string, DialogState>();
  originalStates.forEach(state => {
    originalStateMap.set(state.name, state);
  });

  // 현재 상태에서 이름으로 매핑 생성
  const currentStateMap = new Map<string, DialogState>();
  currentStates.forEach(state => {
    currentStateMap.set(state.name, state);
  });

  // 추가된 상태와 수정된 상태 찾기
  currentStates.forEach(currentState => {
    const originalState = originalStateMap.get(currentState.name);
    
    if (!originalState) {
      // 새로 추가된 상태
      changes.added.push(currentState);
    } else if (!areDialogStatesEqual(originalState, currentState)) {
      // 수정된 상태
      changes.modified.push(currentState);
    }
  });

  // 삭제된 상태 찾기
  originalStates.forEach(originalState => {
    if (!currentStateMap.has(originalState.name)) {
      changes.removed.push(originalState);
    }
  });

  // scenarioTransitionNodes 비교 추가 (자동 생성된 종료 노드 완전 제외)
  const originalTransitionNodes: FlowNode[] = (originalScenario?.plan[0] as any)?.scenarioTransitionNodes || [];
  
  // 자동 생성된 종료 노드를 완전히 제외한 현재 전이 노드들만 추출 (플랜 전이 제외)
  const currentTransitionNodes: FlowNode[] = currentNodes.filter(n => {
    // 자동 생성된 종료 노드인지 확인 (더 정확한 필터링)
    const isAutoGeneratedEndNode = (
      (n.type === 'custom' && n.id.startsWith('end-')) ||
      (n.data.dialogState.name === '__END_SCENARIO__' || 
       n.data.dialogState.name === '__END_SESSION__' || 
       n.data.dialogState.name === '__END_PROCESS__')
    );
    
    // 실제 시나리오 전이 노드만 포함 (type이 'scenarioTransition'이고 자동 생성된 종료 노드가 아닌 것)
    return n.type === 'scenarioTransition' && !isAutoGeneratedEndNode;
  });

  // 전이 노드를 의미 기반으로 비교하기 위한 키 (id 대신 타겟 기준)
  const makeTransitionKey = (n: FlowNode) => `${n.data?.targetScenario || ''}::${n.data?.targetState || ''}`;

  // 의미 기반 매핑 (id 대신 key 사용)
  const originalTransitionMapByKey = new Map<string, FlowNode>();
  originalTransitionNodes.forEach(n => originalTransitionMapByKey.set(makeTransitionKey(n), n));
  const currentTransitionMapByKey = new Map<string, FlowNode>();
  currentTransitionNodes.forEach(n => currentTransitionMapByKey.set(makeTransitionKey(n), n));

  // 추가/수정된 전이노드 (position/label 차이는 무시, 타겟만 비교)
  currentTransitionNodes.forEach(n => {
    const key = makeTransitionKey(n);
    const orig = originalTransitionMapByKey.get(key);
    if (!orig) {
      changes.added.push(n.data.dialogState); // 새로 추가된 전이노드
    } else {
      // targetScenario, targetState만 비교 (label/position 무시)
      const norm = (v: any) => (v ?? '').toString();
      if (
        norm(n.data.targetScenario) !== norm(orig.data.targetScenario) ||
        norm(n.data.targetState) !== norm(orig.data.targetState)
      ) {
        changes.modified.push(n.data.dialogState);
      }
    }
  });

  // 삭제된 전이노드 (의미 기반 키로 판단)
  originalTransitionNodes.forEach(n => {
    const key = makeTransitionKey(n);
    if (!currentTransitionMapByKey.has(key)) {
      changes.removed.push(n.data.dialogState);
    }
  });

  return changes;
};

/**
 * 시나리오를 JSON 파일로 다운로드
 */
export const downloadScenarioAsJSON = (scenario: Scenario, filename: string) => {
  // 보안을 위해 apicall.url 필드 제거
  const scenarioForDownload = JSON.parse(JSON.stringify(scenario));
  removeApiCallUrlsFromScenario(scenarioForDownload);
  
  const dataStr = JSON.stringify(scenarioForDownload, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  const url = URL.createObjectURL(dataBlob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = filename.endsWith('.json') ? filename : `${filename}.json`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

/**
 * 시나리오 유효성 검증
 */
export const validateScenario = (scenario: any): boolean => {
  if (!scenario || typeof scenario !== 'object') return false;
  if (!scenario.plan || !Array.isArray(scenario.plan)) return false;
  if (scenario.plan.length === 0) return false;
  
  const firstPlan = scenario.plan[0];
  if (!firstPlan.dialogState || !Array.isArray(firstPlan.dialogState)) return false;
  
  return true;
};

/**
 * 변경사항이 있는지 확인
 */
export const hasScenarioChanges = (changes: ScenarioChanges): boolean => {
  return changes.added.length > 0 || 
         changes.modified.length > 0 || 
         changes.removed.length > 0;
};

/**
 * 변경사항 요약 텍스트 생성
 */
export const getChangesSummary = (changes: ScenarioChanges): string => {
  const parts: string[] = [];
  
  if (changes.added.length > 0) {
    parts.push(`${changes.added.length}개 추가`);
  }
  
  if (changes.modified.length > 0) {
    parts.push(`${changes.modified.length}개 수정`);
  }
  
  if (changes.removed.length > 0) {
    parts.push(`${changes.removed.length}개 삭제`);
  }
  
  return parts.length > 0 ? parts.join(', ') : '변경사항 없음';
}; 

/**
 * 모든 apicallHandlers의 apicall.url 필드를 삭제 (보안/내보내기용)
 */
export function removeApiCallUrlsFromScenario(scenarioOrArray: any) {
  // 여러 시나리오 배열 지원
  const scenarios = Array.isArray(scenarioOrArray) ? scenarioOrArray : [scenarioOrArray];
  scenarios.forEach((scenario) => {
    if (!scenario?.plan) return;
    scenario.plan.forEach((plan: any) => {
      if (!plan?.dialogState) return;
      plan.dialogState.forEach((state: any) => {
        if (Array.isArray(state.apicallHandlers)) {
          state.apicallHandlers.forEach((handler: any) => {
            if (handler.apicall && handler.apicall.url) {
              // eslint-disable-next-line no-console
              console.info(`[REMOVE_URL] state: ${state.name}, handler: ${handler.name} - url 삭제됨 (removed)`);
              delete handler.apicall.url;
            } else {
              // eslint-disable-next-line no-console
              console.info(`[REMOVE_URL] state: ${state.name}, handler: ${handler.name} - url 없음 (no url field)`);
            }
          });
        }
      });
    });
  });
} 