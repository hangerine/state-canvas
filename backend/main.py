import uvicorn
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException, UploadFile, File, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, JSONResponse
import json
import uuid
from typing import Dict, Any, List, Optional, Union
from pydantic import BaseModel, Field
import logging
import requests

from models.scenario import Scenario, ProcessInputRequest, LegacyProcessInputRequest, StateTransition, UserInput, TextContent, CustomEventContent, ChatbotInputRequest, ChatbotProcessRequest
from services.state_engine import StateEngine
from services.websocket_manager import WebSocketManager
from services.context_store import build_context_store_from_env
from nlu.router import router as nlu_router
from webhook.handler import webhook_router, apicall_router

# Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# FastAPI Ïï± ÏÉùÏÑ±
app = FastAPI(
    title="StateCanvas Backend",
    description="JSON Í∏∞Î∞ò ÏãúÎÇòÎ¶¨Ïò§ State Flow Ï≤òÎ¶¨ Î∞±ÏóîÎìú",
    version="1.0.0"
)

# CORS ÏÑ§Ï†ï
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://localhost:5173"],  # React Í∞úÎ∞ú ÏÑúÎ≤Ñ
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ÎùºÏö∞ÌÑ∞ Îì±Î°ù
app.include_router(nlu_router)
app.include_router(webhook_router)
app.include_router(apicall_router)

# Ï†ÑÏó≠ ÏÉÅÌÉú
state_engine = StateEngine()
websocket_manager = WebSocketManager()
active_sessions: Dict[str, Dict[str, Any]] = {}
context_store = build_context_store_from_env()
import os
SCENARIO_DIR = os.getenv("SCENARIO_DIR", "").strip()

# ÏÑ∏ÏÖò Î©îÎ™®Î¶¨ Í¥ÄÎ¶¨ Ìï®ÏàòÎì§
def get_or_create_session_memory(session_id: str) -> Dict[str, Any]:
    """ÏÑ∏ÏÖò Î©îÎ™®Î¶¨Î•º Í∞ÄÏ†∏Ïò§Í±∞ÎÇò ÏÉùÏÑ±Ìï©ÎãàÎã§."""
    if session_id not in active_sessions:
        active_sessions[session_id] = {
            "current_state": "Start",
            "memory": {"sessionId": session_id},
            "history": [],
            "scenario": None
        }
    return active_sessions[session_id]["memory"]

def update_session_memory(session_id: str, memory: Dict[str, Any]) -> None:
    """ÏÑ∏ÏÖò Î©îÎ™®Î¶¨Î•º ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§."""
    if session_id not in active_sessions:
        active_sessions[session_id] = {
            "current_state": "Start",
            "memory": memory,
            "history": [],
            "scenario": None
        }
    else:
        # üöÄ ÌïµÏã¨ ÏàòÏ†ï: Í∏∞Ï°¥ Î©îÎ™®Î¶¨Î•º Î≥¥Ï°¥ÌïòÎ©¥ÏÑú ÏÉàÎ°úÏö¥ Î©îÎ™®Î¶¨Î°ú ÏóÖÎç∞Ïù¥Ìä∏
        existing_memory = active_sessions[session_id].get("memory", {})
        if existing_memory:
            # Í∏∞Ï°¥ Î©îÎ™®Î¶¨Î•º Î≥¥Ï°¥ÌïòÎ©¥ÏÑú ÏÉàÎ°úÏö¥ Î©îÎ™®Î¶¨Î°ú ÏóÖÎç∞Ïù¥Ìä∏
            merged_memory = existing_memory.copy()
            merged_memory.update(memory)
            active_sessions[session_id]["memory"] = merged_memory
            logger.info(f"[MEMORY UPDATE] Merged memory for session: {session_id}")
            logger.info(f"[MEMORY UPDATE] Existing keys: {list(existing_memory.keys())}")
            logger.info(f"[MEMORY UPDATE] New keys: {list(memory.keys())}")
            logger.info(f"[MEMORY UPDATE] Merged keys: {list(merged_memory.keys())}")
        else:
            active_sessions[session_id]["memory"] = memory

@app.get("/")
async def root():
    return {"message": "StateCanvas Backend API", "version": "1.0.0"}

@app.get("/health")
async def health_check():
    return {"status": "healthy", "engine_status": "running"}

# ÏãúÎÇòÎ¶¨Ïò§ ÌååÏùº ÏóÖÎ°úÎìú
@app.post("/api/upload-scenario")
async def upload_scenario(file: UploadFile = File(...)):
    """ÏãúÎÇòÎ¶¨Ïò§ JSON ÌååÏùº ÏóÖÎ°úÎìú (Ïó¨Îü¨ Í∞ú Í∞ÄÎä•)"""
    try:
        content = await file.read()
        scenario_data = json.loads(content.decode('utf-8'))
        # Ïó¨Îü¨ ÏãúÎÇòÎ¶¨Ïò§ ÏßÄÏõê
        scenarios = scenario_data if isinstance(scenario_data, list) else [scenario_data]
        # State engineÏóê Î°úÎìú
        session_id = str(uuid.uuid4())
        state_engine.load_scenario(session_id, scenarios)
        logger.info(f"Scenario(s) uploaded for session: {session_id}")
        return {
            "status": "success",
            "session_id": session_id,
            "scenario": scenario_data,
            "message": "ÏãúÎÇòÎ¶¨Ïò§Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏóÖÎ°úÎìúÎêòÏóàÏäµÎãàÎã§."
        }
    except json.JSONDecodeError as e:
        raise HTTPException(status_code=400, detail=f"JSON ÌååÏã± Ïò§Î•ò: {str(e)}")
    except Exception as e:
        logger.error(f"Upload error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ÏóÖÎ°úÎìú Ïò§Î•ò: {str(e)}")

# ÏãúÎÇòÎ¶¨Ïò§ ÌååÏùº Îã§Ïö¥Î°úÎìú
@app.get("/api/download-scenario/{session_id}")
async def download_scenario(session_id: str):
    """ÏãúÎÇòÎ¶¨Ïò§ JSON ÌååÏùº Îã§Ïö¥Î°úÎìú (apicallHandlersÏùò url ÌïÑÎìú Ï†úÍ±∞)"""
    try:
        scenario_data = state_engine.get_scenario(session_id)
        if not scenario_data:
            raise HTTPException(status_code=404, detail="ÏãúÎÇòÎ¶¨Ïò§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")

        # ÌÜµÌï© Ï†ÄÏû• Í∑úÏπô:
        # - webhooks Î∞∞Ïó¥Ïóê WEBHOOK/APICALLÏùÑ Ìï®Íªò Ï†ÄÏû• (type ÌïÑÎìúÎ°ú Íµ¨Î∂Ñ)
        # - legacy apicallsÎäî webhooks(type='APICALL')Î°ú Ïù¥Îèô ÌõÑ ÏÇ≠Ï†ú
        def unify_webhooks_and_apicalls(scenario: Dict[str, Any]):
            # Í∏∞Î≥∏ webhooks Î≥¥Ïû•
            webhooks = scenario.get("webhooks", []) or []
            # Í∏∞Ï°¥ webhookÎì§Ïóê type ÏóÜÏúºÎ©¥ WEBHOOKÏúºÎ°ú ÌëúÍ∏∞
            for w in webhooks:
                if "type" not in w:
                    w["type"] = "WEBHOOK"

            legacy_apicalls = scenario.get("apicalls", []) or []
            if legacy_apicalls:
                # Í∏∞Ï°¥ webhooksÏóêÏÑú APICALL ÌÉÄÏûÖ Ï§ëÎ≥µ Ï†úÍ±∞(Ïù¥Î¶Ñ Í∏∞Ï§Ä)
                existing_apicall_names = {w.get("name") for w in webhooks if str(w.get("type", "")).upper() == "APICALL"}
                for a in legacy_apicalls:
                    name = a.get("name")
                    if name in existing_apicall_names:
                        continue
                    
                    # ÏÉàÎ°úÏö¥ specÏóê ÎßûÏ∂∞ Î≥ÄÌôò
                    formats = a.get("formats", {}) or {}
                    # responseMappings Î≥ÄÌôò (Î†àÍ±∞Ïãú ‚Üí Í∑∏Î£π)
                    def to_groups(m):
                        if not m:
                            return []
                        if isinstance(m, list) and len(m) > 0 and isinstance(m[0], dict) and m[0].get('expressionType'):
                            return m
                        memory, directive = {}, {}
                        if isinstance(m, list):
                            for item in m:
                                t = str(item.get('type', 'memory')).lower()
                                for k, v in (item.get('map') or {}).items():
                                    (directive if t == 'directive' else memory)[k] = v
                        elif isinstance(m, dict):
                            for k, conf in m.items():
                                if isinstance(conf, str):
                                    memory[k] = conf
                                elif isinstance(conf, dict):
                                    t = str(conf.get('type', 'memory')).lower()
                                    expr = conf.get(k)
                                    if not isinstance(expr, str):
                                        for kk, vv in conf.items():
                                            if kk != 'type' and isinstance(vv, str):
                                                expr = vv; break
                                    if isinstance(expr, str):
                                        (directive if t == 'directive' else memory)[k] = expr
                        groups = []
                        if memory: groups.append({ 'expressionType': 'JSON_PATH', 'targetType': 'MEMORY', 'mappings': memory })
                        if directive: groups.append({ 'expressionType': 'JSON_PATH', 'targetType': 'DIRECTIVE', 'mappings': directive })
                        return groups
                    new_formats = {
                        "contentType": formats.get("contentType", "application/json"),
                        "requestTemplate": formats.get("requestTemplate"),

                        "responseProcessing": formats.get("responseProcessing", {}),
                        "responseMappings": to_groups(formats.get("responseMappings")),
                        "headers": formats.get("headers", {}),
                        "queryParams": formats.get("queryParams", [])
                    }
                    
                    webhooks.append({
                        "type": "APICALL",
                        "name": name,
                        "url": a.get("url", ""),
                        "timeoutInMilliSecond": a.get("timeoutInMilliSecond", a.get("timeout", 5000)),
                        "retry": a.get("retry", 3),
                        # webhook Í≥µÌÜµ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Ìò∏Ìôò ÌïÑÎìú
                        "timeoutInMilliSecond": a.get("timeout", 5000),
                        "headers": formats.get("headers", {}) or {},
                        "method": formats.get("method", "POST"),
                        # apicall Í≥†Ïú† Ìè¨Îß∑ Î≥¥Í¥Ä
                        "formats": new_formats
                    })
                scenario["webhooks"] = webhooks
                # legacy ÏÇ≠Ï†ú
                if "apicalls" in scenario:
                    del scenario["apicalls"]

        # apicallHandlersÏùò apicall.url ÌïÑÎìú ÏÇ≠Ï†ú Ìï®Ïàò
        def remove_apicall_urls(scenario):
            # Ïó¨Îü¨ plan, Ïó¨Îü¨ dialogState ÏßÄÏõê
            plans = scenario.get("plan", [])
            for plan in plans:
                dialog_states = plan.get("dialogState", [])
                for state in dialog_states:
                    apicall_handlers = state.get("apicallHandlers", [])
                    for handler in apicall_handlers:
                        if "apicall" in handler and "url" in handler["apicall"]:
                            # ÌïúÍ∏Ä/ÏòÅÎ¨∏ Ï£ºÏÑù: Îã§Ïö¥Î°úÎìú Ïãú Ïô∏Î∂Ä API URL Ï†ïÎ≥¥ Ï†úÍ±∞
                            # Remove url field from apicall when downloading scenario
                            logger.info(f"[REMOVE_URL] state: {state.get('name')}, handler: {handler.get('name')} - url ÏÇ≠Ï†úÎê® (removed)")
                            del handler["apicall"]["url"]
                        else:
                            # ÏÇ≠Ï†úÌï† urlÏù¥ ÏóÜÎäî Í≤ΩÏö∞ÎèÑ Î°úÍ∑∏Î°ú ÎÇ®ÍπÄ
                            logger.info(f"[REMOVE_URL] state: {state.get('name')}, handler: {handler.get('name')} - url ÏóÜÏùå (no url field)")

        # ÏãúÎÇòÎ¶¨Ïò§Í∞Ä Î¶¨Ïä§Ìä∏Ïùº ÏàòÎèÑ ÏûàÏùå
        if isinstance(scenario_data, list):
            for scenario in scenario_data:
                unify_webhooks_and_apicalls(scenario)
                remove_apicall_urls(scenario)
        else:
            unify_webhooks_and_apicalls(scenario_data)
            remove_apicall_urls(scenario_data)

        # ÏûÑÏãú ÌååÏùºÎ°ú Ï†ÄÏû• ÌõÑ Î∞òÌôò
        import tempfile
        import os
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as tmp_file:
            json.dump(scenario_data, tmp_file, indent=2, ensure_ascii=False)
            tmp_filename = tmp_file.name
        return FileResponse(
            tmp_filename,
            media_type='application/json',
            filename='scenario.json'
        )
    except Exception as e:
        logger.error(f"Download error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Îã§Ïö¥Î°úÎìú Ïò§Î•ò: {str(e)}")

# ÏÑ∏ÏÖò Ï¥àÍ∏∞Ìôî ÏöîÏ≤≠ Î™®Îç∏
class ResetSessionRequest(BaseModel):
    scenario: Optional[Dict[str, Any]] = None

class UpdateIntentMappingRequest(BaseModel):
    scenario: str
    intentMapping: List[Dict[str, Any]]

# ÏÑ∏ÏÖò Ï¥àÍ∏∞Ìôî
@app.post("/api/reset-session/{session_id}")
async def reset_session(session_id: str, request: Optional[ResetSessionRequest] = None):
    """ÏÑ∏ÏÖòÏùÑ Ï¥àÍ∏∞ÌôîÌï©ÎãàÎã§ (Ïó¨Îü¨ ÏãúÎÇòÎ¶¨Ïò§ ÏßÄÏõê)"""
    try:
        scenario = None
        initial_state = "Start"  # Í∏∞Î≥∏Í∞í
        # ÏöîÏ≤≠ÏóêÏÑú ÏãúÎÇòÎ¶¨Ïò§ Í∞ÄÏ†∏Ïò§Í∏∞
        if request and request.scenario:
            scenario = request.scenario
            scenarios = scenario if isinstance(scenario, list) else [scenario]
            initial_state = state_engine.get_initial_state(scenarios[0], session_id)
            state_engine.load_scenario(session_id, scenarios)
            # üöÄ Ïä§ÌÉù Îß§ÎãàÏ†ÄÎ°ú ÏÑ∏ÏÖò Ï¥àÍ∏∞Ìôî
            if state_engine.adapter and state_engine.adapter.handler_execution_engine and state_engine.adapter.handler_execution_engine.stack_manager:
                state_engine.adapter.handler_execution_engine.stack_manager.initialize_session(session_id, scenarios[0], initial_state)
        else:
            # Í∏∞Ï°¥ ÏÑ∏ÏÖòÏóêÏÑú ÏãúÎÇòÎ¶¨Ïò§ Í∞ÄÏ†∏Ïò§Í∏∞
            if session_id in active_sessions:
                scenario = active_sessions[session_id].get("scenario")
                if scenario:
                    scenarios = scenario if isinstance(scenario, list) else [scenario]
                    initial_state = state_engine.get_initial_state(scenarios[0], session_id)
                    state_engine.load_scenario(session_id, scenarios)
                    # üöÄ Ïä§ÌÉù Îß§ÎãàÏ†ÄÎ°ú ÏÑ∏ÏÖò Ï¥àÍ∏∞Ìôî
                    if state_engine.adapter and state_engine.adapter.handler_execution_engine and state_engine.adapter.handler_execution_engine.stack_manager:
                        state_engine.adapter.handler_execution_engine.stack_manager.initialize_session(session_id, scenarios[0], initial_state)
        # ÏÑ∏ÏÖò Ï¥àÍ∏∞Ìôî
        active_sessions[session_id] = {
            "current_state": initial_state,
            "memory": {},
            "history": [],
            "scenario": scenario
        }
        logger.info(f"Session {session_id} reset to state: {initial_state}")
        return {
            "status": "success",
            "session_id": session_id,
            "initial_state": initial_state,
            "message": f"ÏÑ∏ÏÖòÏù¥ Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§. Ï¥àÍ∏∞ ÏÉÅÌÉú: {initial_state}"
        }
    except Exception as e:
        logger.error(f"Session reset error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ÏÑ∏ÏÖò Ï¥àÍ∏∞Ìôî Ïò§Î•ò: {str(e)}")

@app.post("/api/intent-mapping")
async def update_intent_mapping(request: UpdateIntentMappingRequest):
    """Intent MappingÏùÑ ÏóÖÎç∞Ïù¥Ìä∏ÌïòÍ≥† StateEngineÏóê Ïã§ÏãúÍ∞Ñ Î∞òÏòÅÌï©ÎãàÎã§."""
    try:
        logger.info(f"Updating intent mapping for scenario: {request.scenario}")
        
        # StateEngineÏóê Intent Mapping ÏóÖÎç∞Ïù¥Ìä∏
        state_engine.update_intent_mapping(request.intentMapping)
        
        # Î™®Îì† ÏÑ∏ÏÖòÏùò ÏãúÎÇòÎ¶¨Ïò§ ÏóÖÎç∞Ïù¥Ìä∏
        for session_id, session_data in active_sessions.items():
            if session_data.get("scenario") and session_data["scenario"].get("plan"):
                # ÏãúÎÇòÎ¶¨Ïò§Ïóê intentMapping ÏóÖÎç∞Ïù¥Ìä∏
                session_data["scenario"]["intentMapping"] = request.intentMapping
                logger.info(f"Updated intent mapping for session: {session_id}")
        
        logger.info("Intent mapping updated successfully")
        
        return {
            "status": "success",
            "message": "Intent mapping updated successfully",
            "intentMapping": request.intentMapping
        }
        
    except Exception as e:
        logger.error(f"Error updating intent mapping: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to update intent mapping: {str(e)}")

# ÏÉàÎ°úÏö¥ userInput ÌòïÏãùÏùÑ ÏßÄÏõêÌïòÎäî ÏóîÎìúÌè¨Ïù∏Ìä∏
class MultiScenarioProcessInputRequest(ProcessInputRequest):
    scenario: Union[Dict[str, Any], List[Dict[str, Any]]] = Field(...)

@app.post("/api/process-input")
async def process_input(request: MultiScenarioProcessInputRequest):
    """
    ÏÉàÎ°úÏö¥ userInput ÌòïÏãùÏúºÎ°ú ÏÇ¨Ïö©Ïûê ÏûÖÎ†•ÏùÑ Ï≤òÎ¶¨ÌïòÍ≥† State Ï†ÑÏù¥Î•º ÏàòÌñâÌï©ÎãàÎã§.
    """
    logger.info(f"üì• Processing userInput: session={request.sessionId}, state={request.currentState}, userInput={request.userInput}")
    
    # ÏÑ∏ÏÖò Î©îÎ™®Î¶¨ Í∞ÄÏ†∏Ïò§Í∏∞ ÎòêÎäî ÏÉùÏÑ±
    memory = get_or_create_session_memory(request.sessionId)
    
    # userInputÏóêÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú Î∞è Î©îÎ™®Î¶¨ Ï†ÄÏû•
    user_text = ""
    if request.userInput.type == "text":
        if isinstance(request.userInput.content, dict) and "text" in request.userInput.content:
            user_text = request.userInput.content["text"]
            
            # NLU Í≤∞Í≥ºÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ Î©îÎ™®Î¶¨Ïóê Ï†ÄÏû• (ÎîïÏÖîÎÑàÎ¶¨ ÌòïÌÉú)
            if "nluResult" in request.userInput.content and request.userInput.content["nluResult"]:
                memory["NLU_RESULT"] = request.userInput.content["nluResult"]
        else:
            # TextContent Í∞ùÏ≤¥Ïù∏ Í≤ΩÏö∞
            user_text = request.userInput.content.text if hasattr(request.userInput.content, 'text') else ""
            
            # NLU Í≤∞Í≥ºÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ Î©îÎ™®Î¶¨Ïóê Ï†ÄÏû• (Í∞ùÏ≤¥ ÌòïÌÉú)
            if hasattr(request.userInput.content, 'nluResult') and request.userInput.content.nluResult:
                memory["NLU_RESULT"] = request.userInput.content.nluResult.dict()
        
        if user_text.strip():
            memory["USER_TEXT_INPUT"] = [user_text.strip()]
    
    elif request.userInput.type == "customEvent":
        if isinstance(request.userInput.content, dict) and "type" in request.userInput.content:
            event_type = request.userInput.content["type"]
        else:
            # CustomEventContent Í∞ùÏ≤¥Ïù∏ Í≤ΩÏö∞
            event_type = request.userInput.content.type if hasattr(request.userInput.content, 'type') else ""
        
        memory["CUSTOM_EVENT"] = {
            "type": event_type,
            "content": request.userInput.content.dict() if hasattr(request.userInput.content, 'dict') else request.userInput.content
        }
    
    # Ïó¨Îü¨ ÏãúÎÇòÎ¶¨Ïò§ ÏßÄÏõê
    scenarios: List[Dict[str, Any]] = request.scenario if isinstance(request.scenario, list) else [request.scenario]
    if not scenarios:
        raise HTTPException(status_code=400, detail="No scenario(s) provided.")
    state_engine.load_scenario(request.sessionId, scenarios)
    
    # ÏûÖÎ†• Ï≤òÎ¶¨ (Í∏∞Ï°¥ state_engineÏùÄ ÌÖçÏä§Ìä∏Î•º Í∏∞ÎåÄÌïòÎØÄÎ°ú Î≥ÄÌôò)
    result = await state_engine.process_input_v2(
        session_id=request.sessionId,
        user_input=user_text,
        current_state=request.currentState,
        scenario=scenarios[0],
        memory=memory,
        event_type=request.eventType
    )
    
    # ÏÑ∏ÏÖò Î©îÎ™®Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏
    update_session_memory(request.sessionId, result.get("memory", memory))
    
    logger.info(f"üì§ Processing result: {result}")
    return result

# ÏÉàÎ°úÏö¥ Ï±óÎ¥á ÏûÖÎ†• Ìè¨Îß∑ÏùÑ ÏßÄÏõêÌïòÎäî ÏóîÎìúÌè¨Ïù∏Ìä∏
class MultiScenarioChatbotProcessRequest(ChatbotProcessRequest):
    scenario: Union[Dict[str, Any], List[Dict[str, Any]]] = Field(...)

@app.post("/api/process-chatbot-input")
async def process_chatbot_input(request: MultiScenarioChatbotProcessRequest):
    """
    ÏÉàÎ°úÏö¥ Ï±óÎ¥á ÏûÖÎ†• Ìè¨Îß∑ÏúºÎ°ú ÏÇ¨Ïö©Ïûê ÏûÖÎ†•ÏùÑ Ï≤òÎ¶¨ÌïòÍ≥† State Ï†ÑÏù¥Î•º ÏàòÌñâÌï©ÎãàÎã§.
    """
    logger.info(f"üì• Processing chatbot input: userId={request.userId}, sessionId={request.sessionId}, requestId={request.requestId}, botId={request.botId}, state={request.currentState}")
    
    # ÏÑ∏ÏÖò Î©îÎ™®Î¶¨ Í∞ÄÏ†∏Ïò§Í∏∞ ÎòêÎäî ÏÉùÏÑ±
    memory = get_or_create_session_memory(request.sessionId)
    
    # Ï±óÎ¥á Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Î•º Î©îÎ™®Î¶¨Ïóê Ï†ÄÏû•
    memory["CHATBOT_METADATA"] = {
        "userId": request.userId,
        "botId": request.botId,
        "botVersion": request.botVersion,
        "botName": request.botName,
        "botResourcePath": request.botResourcePath,
        "requestId": request.requestId,
        "context": request.context,
        "headers": request.headers
    }
    
    # userInputÏóêÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú Î∞è Î©îÎ™®Î¶¨ Ï†ÄÏû•
    user_text = ""
    if request.userInput.type == "text":
        if isinstance(request.userInput.content, dict) and "text" in request.userInput.content:
            user_text = request.userInput.content["text"]
        else:
            # TextContent Í∞ùÏ≤¥Ïù∏ Í≤ΩÏö∞
            user_text = request.userInput.content.text if hasattr(request.userInput.content, 'text') else ""
        
        if user_text.strip():
            memory["USER_TEXT_INPUT"] = [user_text.strip()]
            
            # NLU Í≤∞Í≥ºÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ Î©îÎ™®Î¶¨Ïóê Ï†ÄÏû•
            if hasattr(request.userInput.content, 'nluResult') and request.userInput.content.nluResult:
                memory["NLU_RESULT"] = request.userInput.content.nluResult.dict()
    
    elif request.userInput.type == "customEvent":
        if isinstance(request.userInput.content, dict) and "type" in request.userInput.content:
            event_type = request.userInput.content["type"]
        else:
            # CustomEventContent Í∞ùÏ≤¥Ïù∏ Í≤ΩÏö∞
            event_type = request.userInput.content.type if hasattr(request.userInput.content, 'type') else ""
        
        memory["CUSTOM_EVENT"] = {
            "type": event_type,
            "content": request.userInput.content.dict() if hasattr(request.userInput.content, 'dict') else request.userInput.content
        }
    
    scenarios: List[Dict[str, Any]] = request.scenario if isinstance(request.scenario, list) else [request.scenario]
    if scenarios:
        state_engine.load_scenario(request.sessionId, scenarios)
    else:
        scenario_loaded = state_engine.get_scenario(request.sessionId)
        if not scenario_loaded:
            raise HTTPException(status_code=400, detail="No scenario loaded for session and none provided.")
        scenarios = [scenario_loaded]
    
    # ÏûÖÎ†• Ï≤òÎ¶¨ (Í∏∞Ï°¥ state_engineÏùÄ ÌÖçÏä§Ìä∏Î•º Í∏∞ÎåÄÌïòÎØÄÎ°ú Î≥ÄÌôò)
    result = await state_engine.process_input_v2(
        session_id=request.sessionId,
        user_input=user_text,
        current_state=request.currentState,
        scenario=scenarios[0],
        memory=memory,
        event_type=request.eventType
    )
    
    # ÏÑ∏ÏÖò Î©îÎ™®Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏
    update_session_memory(request.sessionId, result.get("memory", memory))
    
    # ÏÉàÎ°úÏö¥ Ï±óÎ¥á ÏùëÎãµ Ìè¨Îß∑ÏúºÎ°ú Î≥ÄÌôò
    chatbot_response = state_engine.create_chatbot_response(
        new_state=result.get("new_state", request.currentState),
        response_messages=[result.get("response", "")],
        intent=result.get("intent", ""),
        entities=result.get("entities", {}),
        memory=result.get("memory", memory),
        scenario=scenarios[0],
        used_slots=None,  # TODO: Ï∂îÌõÑ Íµ¨ÌòÑ
        event_type=request.eventType
    )
    
    logger.info(f"üì§ Processing result: {chatbot_response.dict()}")
    return chatbot_response

# --- bdm-new compatible execute endpoint ---
from fastapi import Request as FastApiRequest

@app.post("/api/v1/execute")
async def execute_endpoint(req: FastApiRequest):
    try:
        payload = await req.json()
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Invalid JSON: {str(e)}")

    user_id = payload.get("userId", "")
    bot_id = payload.get("botId", "")
    bot_version = payload.get("botVersion", "")
    session_id = payload.get("sessionId", str(uuid.uuid4()))
    request_id = payload.get("requestId", f"req-{uuid.uuid4().hex[:8]}")
    user_input = payload.get("userInput", {})
    context = payload.get("context", {})
    headers = payload.get("headers", {})

    # load scenario from SCENARIO_DIR if provided
    scenario = state_engine.get_scenario(session_id)
    if not scenario:
        if not SCENARIO_DIR:
            raise HTTPException(status_code=400, detail="SCENARIO_DIR is not set and no scenario loaded for session.")
        import os
        import json as _json
        file_name = f"{bot_id}-{bot_version}.json"
        file_path = os.path.join(SCENARIO_DIR, file_name)
        if not os.path.exists(file_path):
            raise HTTPException(status_code=404, detail=f"Scenario file not found: {file_path}")
        with open(file_path, "r", encoding="utf-8") as f:
            scenario_data = _json.load(f)
        # support list or dict
        scenarios = scenario_data if isinstance(scenario_data, list) else [scenario_data]
        state_engine.load_scenario(session_id, scenarios)
        scenario = scenarios[0]

    # restore dialog memory/stack from context store
    context_key = f"{session_id}__bot_builder_dm"
    snapshot = await context_store.get(context_key)
    memory = get_or_create_session_memory(session_id)
    
    # üöÄ ÌïµÏã¨ ÏàòÏ†ï: Î©îÎ™®Î¶¨ Î≥ëÌï© Î°úÏßÅ Ï†ïÎ¶¨
    # 1. context_storeÏóêÏÑú Î©îÎ™®Î¶¨ Î≥µÏõê (Ïö∞ÏÑ†ÏàúÏúÑ 1)
    if snapshot and isinstance(snapshot, dict):
        mem_data = snapshot.get("memory", {})
        if isinstance(mem_data, dict):
            memory.update(mem_data)
            logger.info(f"[MEMORY DEBUG] Restored from context_store: {list(mem_data.keys())}")
        # restore session stack if available
        stack_data = snapshot.get("stack")
        if isinstance(stack_data, list):
            state_engine.session_stacks[session_id] = stack_data
    
    # 2. active_sessionsÏóêÏÑú Î©îÎ™®Î¶¨ Î≥ëÌï© (Ïö∞ÏÑ†ÏàúÏúÑ 2)
    if session_id in active_sessions:
        previous_memory = active_sessions[session_id].get("memory", {})
        if previous_memory:
            # Í∏∞Ï°¥ Î©îÎ™®Î¶¨Î•º Î≥¥Ï°¥ÌïòÎ©¥ÏÑú ÏÉàÎ°úÏö¥ Î©îÎ™®Î¶¨Î°ú ÏóÖÎç∞Ïù¥Ìä∏
            for key, value in previous_memory.items():
                if key not in memory:
                    memory[key] = value
            logger.info(f"[MEMORY DEBUG] Merged from active_sessions: {list(previous_memory.keys())}")
    
    logger.info(f"[MEMORY DEBUG] Final memory keys: {list(memory.keys())}")

    # hydrate metadata
    memory["sessionId"] = session_id
    memory["requestId"] = request_id
    memory["CHATBOT_METADATA"] = {
        "userId": user_id,
        "botId": bot_id,
        "botVersion": bot_version,
        "botName": payload.get("botName", ""),
        "botResourcePath": payload.get("botResourcePath"),
        "requestId": request_id,
        "context": context,
        "headers": headers,
    }

    # extract text
    text_input = ""
    if isinstance(user_input, dict) and user_input.get("type") == "text":
        content = user_input.get("content", {})
        text_input = content.get("text", "")
        if text_input.strip():
            memory["USER_TEXT_INPUT"] = [text_input.strip()]
        # NLU result passthrough if any
        if "nluResult" in content and content["nluResult"]:
            # üöÄ NLU_RESULTÎ•º Ïò¨Î∞îÎ•∏ ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
            nlu_result = content["nluResult"]
            if isinstance(nlu_result, dict) and "intent" in nlu_result:
                # Îã®ÏàúÌïú intent ÌòïÏãùÏùÑ NLU_RESULT ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
                memory["NLU_RESULT"] = {
                    "results": [{
                        "nluNbest": [{
                            "intent": nlu_result["intent"],
                            "entities": nlu_result.get("entities", [])
                        }]
                    }]
                }
            else:
                # Ïù¥ÎØ∏ Ïò¨Î∞îÎ•∏ ÌòïÏãùÏù∏ Í≤ΩÏö∞ Í∑∏ÎåÄÎ°ú ÏÇ¨Ïö©
                memory["NLU_RESULT"] = nlu_result
    elif isinstance(user_input, dict) and user_input.get("type") == "customEvent":
        content = user_input.get("content", {})
        memory["CUSTOM_EVENT"] = {
            "type": content.get("type", ""),
            "content": content,
        }

    # determine current state from request, stack, or initial
    current_info = state_engine.get_current_scenario_info(session_id)
    # ÏöîÏ≤≠ÏóêÏÑú Î∞õÏùÄ currentStateÎ•º Ïö∞ÏÑ†Ï†ÅÏúºÎ°ú ÏÇ¨Ïö©
    current_state = payload.get("currentState") or current_info.get("dialogStateName") or state_engine.get_initial_state(scenario, session_id)
    
    # Debug: Log the current state for verification
    logger.info(f"[STATE DEBUG] Current state from stack: {current_state}, session: {session_id}")
    
    # ÏÑ∏ÏÖò Ïä§ÌÉù Ï†ÑÏ≤¥ ÏÉÅÌÉú Î°úÍπÖ
    session_stack = state_engine.get_scenario_stack(session_id)
    logger.info(f"[STATE DEBUG] Full session stack: {session_stack}")

    # process input
    result = await state_engine.process_input_v2(
        session_id=session_id,
        user_input=text_input,
        current_state=current_state,
        scenario=scenario,
        memory=memory,
        event_type=payload.get("eventType")
    )

    update_session_memory(session_id, result.get("memory", memory))
    # also update active session's current_state for quick inspection
    try:
        if session_id in active_sessions:
            active_sessions[session_id]["current_state"] = result.get("new_state", current_state)
    except Exception:
        pass

    # üöÄ ÌïµÏã¨ ÏàòÏ†ï: Î©îÎ™®Î¶¨ Ï†ÄÏû• Î°úÏßÅ Ï†ïÎ¶¨
    # context_storeÏóê ÏµúÏ¢Ö Î©îÎ™®Î¶¨ÏôÄ Ïä§ÌÉù Ï†ÄÏû•
    final_memory = active_sessions.get(session_id, {}).get("memory", {})
    final_stack = state_engine.session_stacks.get(session_id, [])
    
    await context_store.set(context_key, {
        "memory": final_memory,
        "stack": final_stack
    })
    
    logger.info(f"[MEMORY SAVE] Saved to context_store: {list(final_memory.keys())}")

    # build response using factory honoring botType
    chatbot_response = state_engine.create_chatbot_response(
        new_state=result.get("new_state", current_state),
        response_messages=[result.get("response", "")],
        intent=result.get("intent", ""),
        entities=result.get("entities", {}),
        memory=result.get("memory", memory),
        scenario=scenario,
        used_slots=None,
        event_type=payload.get("eventType")
    )

    return chatbot_response

# Í∏∞Ï°¥ ÌòïÏãù ÏßÄÏõêÏùÑ ÏúÑÌïú Î†àÍ±∞Ïãú ÏóîÎìúÌè¨Ïù∏Ìä∏
class MultiScenarioLegacyProcessInputRequest(LegacyProcessInputRequest):
    scenario: Union[Dict[str, Any], List[Dict[str, Any]]] = Field(...)

@app.post("/api/process-input-legacy")
async def process_input_legacy(request: MultiScenarioLegacyProcessInputRequest):
    """
    Í∏∞Ï°¥ input ÌòïÏãùÏúºÎ°ú ÏÇ¨Ïö©Ïûê ÏûÖÎ†•ÏùÑ Ï≤òÎ¶¨ÌïòÍ≥† State Ï†ÑÏù¥Î•º ÏàòÌñâÌï©ÎãàÎã§. (Ìò∏ÌôòÏÑ± Ïú†ÏßÄ)
    """
    logger.info(f"üì• Processing legacy input: session={request.sessionId}, state={request.currentState}, input='{request.input}', event={request.eventType}")
    
    # ÏÑ∏ÏÖò Î©îÎ™®Î¶¨ Í∞ÄÏ†∏Ïò§Í∏∞ ÎòêÎäî ÏÉùÏÑ±
    memory = get_or_create_session_memory(request.sessionId)
    
    # ÏÑ∏ÏÖò Î©îÎ™®Î¶¨Ïóê ÏÇ¨Ïö©Ïûê ÏûÖÎ†• Ï†ÄÏû•
    if request.input.strip():
        memory["USER_TEXT_INPUT"] = [request.input.strip()]
    
    scenarios: List[Dict[str, Any]] = request.scenario if isinstance(request.scenario, list) else [request.scenario]
    if not scenarios:
        raise HTTPException(status_code=400, detail="No scenario(s) provided.")
    state_engine.load_scenario(request.sessionId, scenarios)
    
    # ÏûÖÎ†• Ï≤òÎ¶¨
    result = await state_engine.process_input_v2(
        session_id=request.sessionId,
        user_input=request.input,
        current_state=request.currentState,
        scenario=scenarios[0],
        memory=memory,
        event_type=request.eventType
    )
    
    # ÏÑ∏ÏÖò Î©îÎ™®Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏
    update_session_memory(request.sessionId, result.get("memory", memory))
    
    logger.info(f"üì§ Processing result: {result}")
    return result

# Mock API endpoints for testing apicall functionality
@app.post("/mock/nlu")
async def mock_nlu_api(request: Dict[str, Any]):
    """Mock NLU API for testing"""
    text = request.get("text", "")
    session_id = request.get("sessionId", "")
    
    # Simulate NLU processing based on input text
    intent_mapping = {
        "weather": "Weather.Inform",
        "ÎÇ†Ïî®": "Weather.Inform", 
        "hello": "Greeting.Hello",
        "ÏïàÎÖï": "Greeting.Hello",
        "bye": "Greeting.Goodbye",
        "ÏïàÎÖïÌûà": "Greeting.Goodbye",
        "book": "Booking.Request",
        "ÏòàÏïΩ": "Booking.Request"
    }
    
    # Find intent based on text content
    detected_intent = "Fallback.Unknown"
    confidence = 0.3
    
    for keyword, intent in intent_mapping.items():
        if keyword.lower() in text.lower():
            detected_intent = intent
            confidence = 0.85
            break
    
    # Mock response in the format provided by user
    response = {
        "sessionId": session_id,
        "requestId": f"req-{hash(text) % 10000}",
        "NLU_INTENT": {
            "value": detected_intent
        },
        "nlu": {
            "intent": detected_intent,
            "confidence": confidence,
            "entities": []
        },
        "meta": {
            "exactMatch": confidence > 0.8,
            "processingTime": 150
        }
    }
    
    return response

@app.post("/mock/complex-response")
async def mock_complex_response(request: Dict[str, Any]):
    """Mock API with complex nested response for testing various JSONPath scenarios"""
    
    response = {
        "status": "success",
        "data": {
            "users": [
                {
                    "id": 1,
                    "name": "John Doe",
                    "profile": {
                        "age": 30,
                        "location": "Seoul",
                        "preferences": ["music", "sports"]
                    }
                },
                {
                    "id": 2,
                    "name": "Jane Smith", 
                    "profile": {
                        "age": 25,
                        "location": "Busan",
                        "preferences": ["art", "travel", "books"]
                    }
                }
            ],
            "metadata": {
                "total": 2,
                "page": 1,
                "hasMore": False
            }
        },
        "result": {
            "success": True,
            "message": "Data retrieved successfully"
        },
        "timestamp": "2024-01-15T10:30:00Z"
    }
    
    return response

@app.get("/mock/simple-data")
async def mock_simple_data():
    """Mock API with simple response"""
    return {
        "value": "simple_response",
        "count": 42,
        "active": True,
        "items": ["item1", "item2", "item3"]
    }

@app.post("/api/proxy")
async def proxy_endpoint(request: Request):
    data = await request.json()
    endpoint = data.get("endpoint")
    payload = data.get("payload")
    logger.info(f"Proxy endpoint: {endpoint}")
    if not endpoint or not payload:
        return JSONResponse(status_code=400, content={"error": "endpointÏôÄ payloadÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§."})
    try:
        resp = requests.post(endpoint, json=payload, timeout=15)
        logger.info(f"Proxy response: {resp.json()}")
        return JSONResponse(status_code=resp.status_code, content=resp.json() if resp.headers.get('content-type', '').startswith('application/json') else {"raw": resp.text})
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})

# WebSocket Ïó∞Í≤∞
@app.websocket("/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    """WebSocket Ïó∞Í≤∞ Ï≤òÎ¶¨"""
    await websocket_manager.connect(websocket, session_id)
    try:
        while True:
            # ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î°úÎ∂ÄÌÑ∞ Î©îÏãúÏßÄ Î∞õÍ∏∞
            data = await websocket.receive_text()
            message = json.loads(data)
            
            # Î©îÏãúÏßÄ ÌÉÄÏûÖÏóê Îî∞Î•∏ Ï≤òÎ¶¨
            if message.get("type") == "ping":
                await websocket_manager.send_personal_message({
                    "type": "pong",
                    "timestamp": str(uuid.uuid4())
                }, session_id)
            
            logger.info(f"WebSocket message from {session_id}: {message}")
            
    except WebSocketDisconnect:
        websocket_manager.disconnect(session_id)
        logger.info(f"WebSocket disconnected: {session_id}")

# ÏÑ∏ÏÖò ÏÉÅÌÉú Ï°∞Ìöå
@app.get("/api/session/{session_id}")
async def get_session_state(session_id: str):
    """ÏÑ∏ÏÖòÏùò ÌòÑÏû¨ ÏÉÅÌÉú Ï°∞Ìöå"""
    if session_id not in active_sessions:
        raise HTTPException(status_code=404, detail="ÏÑ∏ÏÖòÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.")
    
    return {
        "session_id": session_id,
        "state": active_sessions[session_id]
    }

# ÏÑ∏ÏÖò Î™©Î°ù Ï°∞Ìöå
@app.get("/api/sessions")
async def list_sessions():
    """ÌôúÏÑ± ÏÑ∏ÏÖò Î™©Î°ù Ï°∞Ìöå"""
    return {
        "active_sessions": list(active_sessions.keys()),
        "count": len(active_sessions)
    }

# Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò ÏãúÏûë Ïãú
@app.on_event("startup")
async def startup_event():
    logger.info("StateCanvas Backend started")

# Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖò Ï¢ÖÎ£å Ïãú
@app.on_event("shutdown")
async def shutdown_event():
    logger.info("StateCanvas Backend shutting down") 
